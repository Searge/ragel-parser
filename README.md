
# Синтаксический анализ и валидация данных на основе конечных автоматов (Ragel).


Достаточно часто в работе встречаются задачи связанные с синтаксическим анализом (далее __парсингом__) структурированных данных.
Иногда размеры полей таких структур имеют фиксированную длину,а иногда ширина поля зависит от типа структуры(или размер задаётся значением поля). 


Для парсинга простых структур с фиксированным размером, иногда достаточно написать простую функцию основанную на адресной арифметике.
Если поля структур определены разделителями (к примеру CSV), то можно воспользоваться  токенайзером (от token, tokenizer).  
В случаях когда структура данных подчиняется нетривиальной логике, то можно воспользоваться регулярными выражениями (regex). 

Воспользоваться можно, но иногда regex не достаточно гибок. Иногда не достаточно производителен - за счет широких возможностей,
инструмент делает даже больше чем требуется (с соответствующим 'пенальти' по скорости).

Далее предлагается альтернативное решение основанное на практически неограниченной гибкости, с превосходной функциональностью и производительностью: Ragel.
Ragel — компилятор конечных автоматов, производящий исходный код на  C/C++, C#, Objective-C, D, Java, O'Caml, Go и Ruby.

Описание возможностей со страницы Википедии ([ссылка](https://ru.wikipedia.org/wiki/Ragel)):

>Исходным текстом конечного автомата для Ragel служит расширенный язык регулярных выражений и/или диаграмма состояний конечного автомата. Ragel хорошо подходит для построения лексических анализаторов и спецификации протоколов передачи данных.
>Ragel позволяет внедрять в любой точке выполнения автомата определяемые пользователем действия. С целью разрешения недетерминизма предусмотрена система приоритетов для операторов регулярного языка.


Реализация парсера на Ragel фактически похожа на объявление формальной системы описания синтаксиса ([БНФ](https://ru.wikipedia.org/wiki/%D0%A4%D0%BE%D1%80%D0%BC%D0%B0_%D0%91%D1%8D%D0%BA%D1%83%D1%81%D0%B0_%E2%80%94_%D0%9D%D0%B0%D1%83%D1%80%D0%B0)) .


Описание парсера на Ragel можно условно разделить на 4 части (пример для C++):

#### 1. Объявление служебных переменных
Ragel рассчитывает на то что в зоне видимости будут объявлены переменные, которые будут использованы для работы конечного автомата (далее КА).

```с
int cs 0;                             //числовое представления текущего состояния 
int top = 0;                          //глубина рекурсии, при явном переходе между состояниями
int stack[1024] = {0};                //стек для хранения переходов. В данном случае 1024 - максимальная
                                      // глубина вложенности
                                       
const char *p =  <some str>;          //указатель на начало разбираемых данных
const char *pe = p + <size of data>;  //указатель на конец данных
const char *eof = pe;                 //тоже что и pe
const char *ts = NULL;                //указатель на начало данных соответствущих КА 
```

Также в коде могут встречаться переменные которые объявлены самим Ragel, и они имеют определённое назначение. 
```с
   fpc ;                    // указатель на текущий 
                            // символ в анализируемой строке
                             
   <имя КА>_error;          // номер состояние КА,
                            // соответсвующий неконсистентному состоянию.
```

#### 2.Объявление КА
```с
%%{
        machine test_easy;

        action greet
        {
                /*
                 * 2.1 c/c++  код здесь в виде action
                 */                
        }

        GREETING_TARGET = "World" | "Me" ;
        SP = space* ',' space*;
        main := "Hello"  SP GREETING_TARGET >{ts=fpc;  /*2.2 c/c++ in-place код здесь */} %greet  ;
    }%%
```

Собственно говоря гибкость Ragel заключается в том, что можно выполнять любой пользовательский код при изменении состояния КА.
Переход КА в требуемое  "начальное"  и "конечное" состояние, собственно говоря и есть критерий успешности разбора последовательности (pattern-match).
При входе и выходе из определённого состояния необходимо сохранить значения встроенной переменной *fpc* .
Все что посредине - фрагмент данных который был валидирован КА. 
Пользовательский код может быть выполнен в теле заранее объявленной специальным образом функции (2.1) или in-place (2.2).

######Пример выполнения пользовательского кода in-place.
```с
    TEST_AUTOMATA = "Hello World" >{ std::cout << "Начало"; }  %{ std::cout << "Конец"; } ;
```


######Пример выполнения пользовательского кода в теле action.
```с
    action my_begin
    {
         std::cout << "Начало";
    }
    
    action my_end
    {
        std::cout << "Конец"; 
    }

    TEST_AUTOMATA = "Hello World" >my_begin  %my_end;
```

######Примеры обработки переходов
```с
   TEST_AUTOMATA  >{ /* c/c++ код здесь */ } - переход в начальное состояние
   TEST_AUTOMATA  <{ /* c/c++ код здесь */ } - переход в любое состояние, кроме начального
   TEST_AUTOMATA  ${ /* c/c++ код здесь */ } - переход в любое состояние
   TEST_AUTOMATA  %{ /* c/c++ код здесь */ } - переход в конечное состояние
   TEST_AUTOMATA  @{ /* c/c++ код здесь */ } - переход в любое состояние, кроме  конечного
   TEST_AUTOMATA <>{ /* c/c++ код здесь */ } - переход в любое состояние, кроме начального и конечного  
```



#### 3.Объявление скрипта генерации кода инициализации и старта КА
```с
%%{
        machine test_easy;   #3.1
        
        action greet { /*код c/c++*/}  #3.2
        GREETING_TARGET = "World" | "Me" ; #3.3
        SP = space* ',' space*;       #3.4
        
        main := "Hello"  SP GREETING_TARGET >{ts=fpc;} %greet  ; #3.5
    }%%
```

Объявление КА обязательно должно содержать имя самого КА.

Объявление имени происходит при помощи директивы **machine** (3.1).

Директива **action** задает функцию, которая будет вызвана по имени, при изменении состояния КА (3.2).
Код вставленный в функцию - обычный C/C++ код, который может обращаться ко всем функциям и переменным в области видимости.

Далее могут быть объявлены один или более пользовательских КА в формате:

  <имя> = <описание> ;   
  
Пользовательские КА могут быть скомбинированы в любом порядке, через операторы .(и) |(или) !(не).

В примере выше  *GREETING_TARGET* может принимать одно из значение  "World" или "Me" (3.3). 

```с
Конечный автомат *SP* - это 0 или более whitespace'ов    
      за которыми идёт символ ','   
         после которого идёт последовательность из 0 или более whitespace'ов.   (3.4)
```      

Любой КА из которого Ragel должен сгенерировать код, должен в себе содержать обязательное объявление **main** (3.5), которое является итоговым
результатом комбинации всех объявленных ранее пользовательских КА.          

Ragel предоставляет встроенные КА, которые могут быть использованы по отдельности либо в составе пользовательских КА.

КА    | Описание                      | Диапазон   |
---   |---                            |---      |
any   | Любой символ |         |
ascii | ASCII символ              |  0..127 |
extend |ASCII символ (расширенный)|-128..127 0..255|
alpha  | Буквенный символ |[A-Za-z]|
digit  | Цифровой символ | [0-9]|
alnum | Буквенноцифровой символ| [0-9A-Za-z]|
lower | Буквенный в нижнем регистре | [a-z]|
upper | Буквенный в верхнем регистре| [A-Z]|
xdigit | Шеснадцатиричная цифра |[0-9A-Fa-f]|
cntrl  | Управляющий симовл |0..31|
graph  | Графический символ |[!-~]|
print  | Печатный символ |[ -~]|
punct  | Пунктуационный символ. Графический , не буквенноцифровой символ | [!-/:-@[-‘{-~]|
space | Разделитель|[\t\v\f\n\r ]|
zlen | Строка с нулевой длиной||
empty| Пустое множество||

Встроенные КА во многом повторяют аналоги из регулярных выражений.

  
#### 4.Проверка конечного состояния КА (проверка валидности парсинга).
```с
     if (cs == test_easy_error )
     {
         /*номер конечного  состояния (cs) соответствует неконсистентному. 
          *позицию (смещение в символах) в строке, которая вызвала ошибку парсера, можно вычислить как 
          *p-<address of <some str>>
          */
     }
     else
     {
         //все хорошо, парсинг произошёл без ошибок.
     }
```
    

### Пример 1 (demo_easy)
В этом примере на вход парсеру подаётся на вход простая строка которая может принимать вид "Hello , **Me**" или 
"Hello , **World**". В случае если входная последовательность соответствует ожидаемой (одной из), выводится сообщение об успешном парсинге.
Если входная последовательность не соответствует ожидаемой - выводится сообщение об ошибке, и индекс символа исходного буфера начиная с которого
КА не смогла перейти в одно из возможных состояний .


### Пример 2 (demo_advanced)
Этот пример несколько усложнён : на вход даётся строка которая из себя представляет некий формат, напоминающий кортежи.
Элементами кортежа могут быть другие кортежи, с глубиной вложенности 1024 (задаётся пользователем).
Программа последовательно выводит значения элементов в консоль построчно, причём отступ при печати зависит от глубины вложенности.
Ragel напрямую не поддерживает возможность описания рекурсивных КА, для обработки вложенных структур.
Для таких случаев есть возможность указать явно, состояние в которое надо перейти.
Связка  *fhold; fcall <метка>* говорят что КА должен перейти в начальное состояние соответствующее КА с именем <метка>.
*fhold* указывает что перед переходом в новое состояние последний обработанный символ не надо принимать в расчёт (откат).
Функция *fret* используется для того, чтобы вернуться в исходное состояние, в котором был КА до вызова *fcall*. 
 
Для того чтобы иметь возможность явно переходить в состояние при помощи *fcall*, должны быть объявлены в текущей области видимости переменные *int top* и
*int stack[N]*, которые используются Ragel для хранения стека переходов .



 
### Интеграция с проектом
Исходным файлом для Ragel является файл с расширением *.rl ;
Для того чтобы сгенерировать парсер на необходимом языке необходимо выполнить команду:

```bash
>ragel -o main_generate.cpp main.rl
```
После этого сгенерированный файл main_generate.cpp может быть вставлен в любой проект (вручную, при помощи Makefile, qmake и т.д.) .

Каждый раз руками генерировать .cpp файл неудобно, поэтому можно средствами вашей системы сборки автоматизировать этот процесс.
Тестовый пример для этих целей использует CMake .

Для успешной компиляции, однако, исходный файл *.rl также необходим, т.к. часть кода импортируется в сгенерированный c/cpp файл  
при помощи директивы line:
```c
#line 44 "main.rl"
```

 

### Для пытливых умов
Конечный автомат сгенерированный Ragel можно визуализировать при помощи graphviz.
Использую опцию '--V' можно сгенерировать .dot файл, являющийся графом переходом между состояниями КА.

```bash
>ragel -V main.rl > main.dot
>dot -Tpng -o main.png main.dot
```
Анализируя сложность графа переходов можно судить об общей эффективности реализованного парсера.
[Пример графа](https://github.com/jbt/markdown-editor)
 


Демо-проект можно взять по [ссылке](https://github.com/jbt/markdown-editor) на GitHub. 

---

Сергей Жуков, Декабрь 2017.
